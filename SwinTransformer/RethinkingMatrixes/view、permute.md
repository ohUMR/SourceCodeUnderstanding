# pytorch维度变换(view、permute、transpose的本质)

## 1.数组保存的方式
无论是Pytorch还是Numpy，数组都是以连续的方式进行保存的。

考虑下面这个a：
```python
a = np.arange(1,17)

out:
[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16]

```
对a进行reshape操作后， a其实仍是以连续的方式保存
```python
a = np.reshape(4,4)

out:
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]]
```
**那么，什么改变了呢？其实就是索引的方式**

当a的shape为(1, 16)时，a的索引只有一个，a[i],这里i的范围为0~15（a[0]~a[15])

而当a的shape变为(4, 4)的时候， a的索引变为了2个，a[i, j]， 这里i的范围是0~4，j也是0~4

**那么，当a的shape变为(2, 2, 4)的时候是怎么切分的？**
这时索引应该为a[i, j, k]

对于(2, 2, 4)里的第一个维度， 程序会把连续的数组切为2份，一份为[1  2  3  4  5  6  7  8], 另一份为[9 10 11 12 13 14 15 16]

即对于i来说，a[0,:,:]对应的**数字**应该为[1  2  3  4  5  6  7  8]，a[1,:,:]对应的**数字**应该为[9 10 11 12 13 14 15 16]

同样的，对于j来说，即是把i控制的两份又各自分为两份，分别为[1  2  3  4]、[5  6  7  8]；[9 10 11 12]、[13 14 15 16]

对k来说同样如此。

画成图的话为下图：
